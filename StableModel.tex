\section{Stable Model Semantics}

\subsection{Stable Models}
\begin{itemize}
    \item Definition
        \begin{itemize}
            \item Relations to nonmonotonic reasoning - autoepistemic logic and default logic.
            \item Reduction process.
        \end{itemize}
    \item Properties.
        \begin{itemize}
            \item Theorem: Any stable set of a logic program $P$ is a minimal Herbrand model of P.
            \item A program $P$ might have no or many stable models -> well-founded semantics fixes this.
            \item Testing whether a finite ground logic program has a stable model is NP-complete.
            \item Limitations: generate all the ground instances in the presence of function symbols.
        \end{itemize}
    \item Datalog and stable models.
\end{itemize}

\subsection{Examples}

\subsection{Answer Set Programming}
\begin{itemize}
    \item ASP constructs: choice rules, cardinality constraints, and disjuntive rules. 
    \item Search problems are reduced to computing stable models.
    \item Programming methodology: generate, define, test
    \item Classical negation + negation as failure = closed world assumption
\end{itemize}