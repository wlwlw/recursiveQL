The query languages we have considered so far, including relational calculus, 
relational algebra, and Datalog, all have their expressive limitations. While 
it is proved that neither the calculus nor the algebra is able to express 
recursive queries, Datalog overcomes this limitation yet still lacks support 
for negation. Consider the following query,
\begin{displayquote}
    \textit{``Find all the pairs of vertices in a 
    graph that are not connected.''}
\end{displayquote}
This query is not possible without the use of both recursion and negation. 
In this paper, we explore the extension of relational calculus with 
recursion using the least fixpoint semantics, as well as examine the interpretation  
of logic programs with negation as failure using the stable model 
and well-founded semantics.

Least Fixpoint Query is an extension to relational calculus that embraces recursion. It extends the expressive power of relational calculus by including the computation of least fixed point into its semantics. The least fixed point here is defined as follow: 
Let $\Phi$ be a mapping between $k$-ary relations that are expressible in relational calculus. Then if a $k$-ary relation $P$ satisfies $P= \Phi(P)$, $P$ is said to be a fixed point of $\Phi$. If $P$ also satisfies $P \subseteq P^*$ for all fixed point $P^*$ of $\Phi$, then $P$ is said to be a least fixed point of $\Phi$.
We will talk least fixed point in more detail in later section. Where you can see least fixed point is guaranteed to exist following the syntax of Least Fixpoint Query. And the computation of it is in PTIME, which furthermore results in the data complexity of Least Fixpoint Query also in PTIME (P-complete precisely). 
In this paper, we will also talk about the improved expressive power of Least Fixpoint Query via an example decision problem called Path Systems, which is expressible in Least Fixpoint Query but not in relational calculus. We will also cover the important theorems behind the reasoning of its expressive power and some sketches of proof.

In addition to recursion, another desirable addition to database query languages 
is negation. In this paper, we explore a weaker version of classical negation called 
\emph{negation as failure} to specify nonmonotonic programs. However, a logic 
program with negation as failure might have more than one minimal Herbrand model 
\footnote{A set of ground terms of a program $P$, whose interpretation 
makes every ground term denote itself.}. Hence, it is important 
to come up with a semantics that defines the correct minimal 
model for a program with and without negation. Two such semantics 
are stable models and well-founded models. A conventional 
definition of a stable model
describes a set $M$ of ground atoms that matches with the least model 
of a grounded program whose negative literals are eliminated with respect to 
$M$. In this sense, the stable model semantics coincides with 
the least model semantics on positive programs. Under this 
semantics, a program can also have multiple stable models. Even though 
this problem can be fixed using the well-founded semantics, 
it makes the stable model semantics suitable for solving search 
problems whose solutions are numerous and incomparable. Such 
application is found in answer set programming (ASP), wherein 
solutions to a search problems are computed as stable models 
that satisfy both the program specifications and additional constraints. 
This type of logic programming based on stable models has lower 
expressive power than the conventional Horn logic programming 
\footnote{Logic programs composed of Horn clauses, 
each of which is a disjunction of literals (atoms or negated atoms) with at most one of 
them positive.}. While Horn programs can express any recursively enumerable set, 
ASP programs are only able to solve decision problems in the NP class. 
Nonetheless, the stable model semantics is still 
a powerful computational tool in artificial 
intelligence and operations research where focus 
revolves around many search and constraint satisfaction 
problems in NP.

In the approaches by stable model semantics and well-founded semantics, it is desirable to associate a Herbrand model with a logic program as its meaning, with the idea that queries to the program are queries directed to this model. However, some programs do not have a ``satisfactory'' total model; it is thus natural to ask whether there are \emph{partial} models for them. Well-founded semantics proposes a good solution to this question, as it generalizes some well-known previous approaches to adding negation to programs.

The organization of this paper is as follows. First, we 
explore the extension of the calculus with recursion 
using the least fixpoint semantics. We then discuss the effects 
of negation in logic programming by describing the nonmonotonic 
formalism behind negation as failure and the problem of 
a program having more than one minimal Herbrand model. Section 4 and 5 
study the stable model and well-founded semantics as the two 
commonly accepted mechanisms to represent logic programs with 
negation. The last section concludes our work.