In conclusion, we have studied the extension of standard query languages with recursion and negation. First, we showed how to embody recursion in relational calculus using the least fixed point, which lead to Least Fixpoint Query. Least Fixpoint Query can express query that are not expressible in relational calculus, e.g.  Path Systems. And we see it makes least fixpoint query having data complexity in P-Complete instead of LOGSPACE in which of relational calculus. And we see important theorem used for analysis of expressive power of relational calculus and logic programs, the Method of Ehrenfeucht-Fra\"{i}ss\'{e} games. From which we can reason Path System is not expressible in relational calculus. Together we see both the expressive power and data complexity of our Least Fixpoint Query. 

Besides recursion, we also explore the effect of adding negation 
to logic programming. In the presence of the negation operator, 
some programs can have more than one least Herbrand model. Therefore, 
we need a different semantics to represent programs with negation 
while still complying with the least model theory. One such 
example is the stable model semantics. The motivation behind 
a stable model is based on the nonmonotonic reasoning, more 
specifically the notion of a unique stable expansion in 
autoepistemic logic. In this sense, negation is represented as 
the absence of belief instead of explicit falsity, thus allowing 
changes in conclusions given new information (or beliefs). The 
most conventional definition of a stable model is described 
using the Gelfond-Lifschitz transformation, which is loosely based on 
autoepistemic logic. Accordingly, a set $M$ of ground atoms is considered 
stable if it matches the least model of the grounded program $\Pi$ reduced 
with respect to $M$. We also studied a more modern definition of a stable 
model using the modified circumscription introduced in Ferraris et al. \cite{lee}. 
This definition removes the necessity of grounding and instead transforms 
a logic program $F$ into a second-order formula, $SM[F]$, that minimizes the extension of 
its predicates. A model of $F$ is stable if it satisfies $SM[F]$. 
Under the stable model semantics, a program is assigned with a 
collection of intended models instead of one. This property 
gives rise to a new paradigm of answer set programming, 
which finds solutions to a search problem as stable models. Applications 
of ASP have been observed in automated product configuration, decision 
support for the space shuttle, and inference of phylogenetic trees. On the other hand, in well-founded semantics the concept of unfounded sets is introduced to encompass negative subgoals and treat them symmetrically as with positive subgoals, so that a larger portion of the Herbrand base can be assigned truth values true or false than in previous approaches. Although the well-founded partial model is defined through transfinite induction, in the context of practical logic programming or in the common situation of function-free programs with finite EDB, the construction of this partial model terminates in finitely many steps.
